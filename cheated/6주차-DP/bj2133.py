# 2133 타일 채우기
"""
    설명 : https://0equal2.tistory.com/114
    n이 홀수이면 만들 수 없다.
    n은 짝수일때만 계산이 가능하므로 n을 2개씩 나눠 생각할때, 3x2를 채우는 경우의 수는 3가지가 있다. "dp[i] = dp[i-2]*3"
    다만 n이 4 이상인 경우를 살펴보면, 3x2로 나눠진 n/2개의 블록 사이를 1x2 블록으로 채우는 경우의 수가 생긴다.
    |=|
    -- 의 경우와 같이 n이 4 이상일 경우, 매번 n이 증가할 때(+2) 다음과 같은 경우의 수가 2가지씩 추가된다.
    즉, "dp[i] = dp[i-2] * 3 + 2"

    나는 초기 접근을, "dp[i] = 3**(n//2) + ?" (? : 규칙에 의해 구한 특수경우들)로 접근했기 때문에 풀지못했다.
    이 문제의 중요한 아이디어는 "dp[i] = dp[i-2]*3"인데, 이것은 이전 특수경우를 포함한 상태로, 그냥 새로운 3x2 블록을 붙였을 때
    경우의 수를 구하고, 현재 i에서 새로 만들어지는 특수한 경우의수는 따로 구해 더하는 것이다.

    특수한 경우의 수를 구하는 것의 예시
    ex) i가 6 이라고하면, dp[6] = dp[4] * 3 + 2 (6에서 나오는 특수경우 2가지)
        for j in ... 을 돌면서
            dp[6] += dp[2] * 2 (3x2에 3x4에 특수경우 2가지를 조합)
    위와 같은 방법으로 풀 수 있다.

    추가 설명
    https://blog.naver.com/cldlakd/221411915772
    for j in...을 빼면, 특이케이스가 왼쪽에 오는 경우밖에 계산이 안됨.
    => 즉, for j in ... 부분은 오른쪽에 특이케이스가 오는 것을 계산해주기 위함이다.
"""
n = int(input())


if n == 2:
    print(3)
    exit(0)
elif n < 4:
    print(0)
    exit(0)

dp = [0] * (n+1)
dp[2] = 3

for i in range(4, n+1):
    if i % 2:
        continue
    dp[i] = dp[i-2] * 3 + 2
    for j in range(2, i-2, 2):
        dp[i] += dp[j] * 2
print(dp[-1])