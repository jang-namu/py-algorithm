# 1720 타일 코드
"""
    좌우가 같은걸 빼는게 아니라, 좌우 대칭인 두 2xN 타일은 하나만 세는 문제
    아이디어 : 전체 경우의 수를 구하고 (2xi는 2x(i-1)에 2x1타일 추가하거나, 2x(i-2)타일에 2x2, 1x2 타일을 추가)
                중앙을 기준으로 좌우가 같은 타일은, 하나밖에 나오지 않음.
                이를 제외한 타일들은 또 다른 타일과 대칭쌍을 이룬다.
                따라서, 전체 경우의 수는 좌우같은타일 + (전체경우수 - 좌우같은타일) // 2
"""

import sys
input = sys.stdin.readline

N = int(input())

if N < 3:
    print(1 if N == 1 else 3)
    exit(0)

dp = [0] * (N+1)
"""
    res에서 4를 구하려면, dp[0]을 1로 초기화해야 한다. 2x2블럭 2개, 즉 위에 설명에서 짝수, 후자의 경우를 구할 때,
    (i-4)//2 = 0이기 때문에 dp[0]을 1로 초기화해줘야 한다.
"""
dp[0], dp[1], dp[2] = 1, 1, 3
for i in range(3, N+1):
    dp[i] = dp[i-1] + dp[i-2] * 2
print(dp)

# 생각해보니 res에 다 저장할 필요없이 마지막만 계산하고 바로 출력하면 된다.
res = [0] * (N+1)
res[1], res[2] = 1, 3
for i in range(3, N+1):
    """
        홀수의 경우, 가운데 2x1 타일이 있는 상태에서, 중앙의 왼쪽을 만드는 갯수만큼 좌우대칭 타일이 만들어진다. 
        ex) 5는 2타일을 만드는 경우수와 같은 좌우대칭 타일이 만들어진다.
        
        짝수의 경우, 가운데 2x2칸을 반갈해서 그 왼쪽을 만드는 경우
            + N이 6일 때, 1 2 2 1과 같이 가운데 2x2칸 두개가 들어가는 경우의 수 만큼 좌우대칭 타일이 만들어진다.
        전자는 반으로 가르는 2x2칸을 만드는 경우의 수(dp[2]) * 그 왼쪽을 만드는 경우(dp[(i-2)//2])로 구할 수 있고
        후자의 경우, 계산할 때 2x2 블록을 만드는 경우(dp[2] - 1 => "-1"은 2x2를 2x1 두개로 만드는 경우를 제외, 전자와 중복) 
            * 2x2 블록 왼쪽을 만드는 경우 dp[(i-4)//2] 로 구할 수 있다.
    """
    if i % 2:
        reflect = dp[(i - 1) // 2]
        res[i] = reflect + (dp[i] - reflect) // 2
    else:
        reflect = 3 * dp[(i-2)//2] + 2 * dp[(i-4)//2]
        res[i] = reflect + (dp[i] - reflect) // 2
        print(reflect, end=", ")
print(res)
print(res[-1])