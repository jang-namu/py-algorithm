# 2262 토너먼트 만들기
"""
    아이디어 : 가장 큰놈부터 선택해서 양쪽을 살펴본다. 차이가 더 적은 측과 대결한다.
    선택한 선수의 양옆으로 구간을 나눠 생각한다. 각 구간의 최종 승자는, 해당 범위 중 가장 낮은 숫자이다.
    즉, 현재 선택한 위치에서 비교하는 방법은 4가지가 있다.
    1. 왼쪽과 비교
    2. 오른쪽과 비교
    3. 왼쪽 범위 중 가장 작은 놈과 비교  (실제로는 가장 작지는 않을 수 있지만, 왼쪽 오른쪽과 비교했을 때 더 작거나 같음은 보장된다.)
    4. 오른쪽 범위 중 가장 작은 놈과 비교 (위와 같다)

    즉, 가장 큰 숫자의 입장에서 생각했을 경우. 현재 왼쪽/오른쪽과 대결하는 것이 가장 차이가 적게난다.
    **우리는 대결을 맺는 순서를 강제하고(큰 숫자부터), 바로 양 옆에 선수 중 큰 숫자와 대진표를 만든다.**

    증명: 1. 왼쪽 또는 오른쪽 구간 중 숫자와 비교 => 바로 양 옆이 그 옆과 대결해야 하ㅛ므로
        => 바로 옆 원소가 유지되거나, 더 작은 숫자로 바뀐다.
"""
import sys
input = sys.stdin.readline

n = int(input())
ranks = list(map(int, input().split()))

ans = 0         # 등수 차이의 합을 저장
for i in range(n, 1, -1):   # 토너먼트가 끝나기 위해 n-1번의 게임이 필요함. (한 게임에 한명씩 탈락하므로)
    for j in range(i):      # 한 번 게임 시마다, 한명이 탈락한다.(remove됨) 따라서 ranks 배열도 n명에서 시작해 n-1, n-2, ...
        if ranks[j] == i:   # 현재 가장 큰 숫자. # j = ranks.index(i)
            if j == 0:      # 배열의 처음
                ans += ranks[j] - ranks[j+1]
            elif j == i-1:  # 배열의 끝
                ans += ranks[j] - ranks[j-1]
            else:           # 가운데이면 좌우측 중 차이가 적은 쪽
                ans += min((ranks[j] - ranks[j-1]), (ranks[j] - ranks[j+1]))
            ranks.remove(ranks[j])  # 가장 큰 수 제거
            break
print(ans)